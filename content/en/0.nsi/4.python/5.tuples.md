---
title: Tuples
description: It is possible to "store" several values in the same structure. This type of structure is called a __sequence__.
---
More precisely, we can define a sequence as a finite and ordered set of elements.

There are two types of sequences in Python: __tuples__ and __lists__.

::cardgrid{ cols=2 }
#title
Differences between tuples and lists

#default
::card{ title="Tuple" to="/nsi/python/tuples" }
`my_tuple = (1, 2, 3)`{lang='python'}  
tuples are __not modifiable__ (we say immutable)
::

::card{ title="List" to="/nsi/python/listes" }
`my_list = [1, 2, 3]`{lang='python'}  
lists are __modifiable__ (we say mutable)
::
::

## Tuples
In mathematics, we call __tuples__ "ordered collections of objects". More precisely, we will call n-tuple or n-tuple a collection containing _n_ objects. You will find more information on the page [:icon{name="mdi:wikipedia"} Tuple - Wikipedia](https://fr.wikipedia.org/wiki/Uplet).  
The common term in programming is the corresponding anglicism, the __tuple__.  

- tuple elements are placed between parentheses: `(val1, val2, val3)`
- tuples are ordered, each element is associated with an index
- tuples are not modifiable
- tuple elements can be of different types: you can combine strings, integers, objects, in the same tuple.

Let's start with a simple example:

``` python 
first_tuple = (1, 9, 42, 13, 24)
```

::imago{src="tuple.png"}
We can represent this tuple with a basic diagram.
::

Thus, in the `first_tuple` variable, we have:

- the __value 1__ at position _0_
- the __value 9__ at position _1_
- the __value 42__ at position _2_
- the __value 13__ at position _3_
- the __value 24__ at position _4_

To access these values, we use bracket-based notation. The code below allows analyzing each element of the tuple. We notice that we can easily make different native types coexist within the same tuple.

::code-group
```python [Tuple analysis]
my_tuple = (42, "cat", 12, True)

print(type(my_tuple), ":", my_tuple)
print(type(my_tuple[0]), ":", my_tuple[0])
print(type(my_tuple[1]), ":", my_tuple[1])
print(type(my_tuple[2]), ":", my_tuple[2])
print(type(my_tuple[3]), ":", my_tuple[3])
```

```bash [result]
<class 'tuple'> : (42, 'cat', 12, True)
<class 'int'> : 42
<class 'str'> : cat
<class 'int'> : 12
<class 'bool'> : True
```
::

:imago{src="tuple1.png" :iwidth="500"}

::callout
A tuple is useful in several cases: it allows a function to return multiple values, such as coordinate pairs, phone numbers, or more generally several values that are linked.
::

Let's take our `addition()` function again. We can modify it so that instead of returning the sum of the two values, it returns a tuple containing value a, value b, and finally the sum of the two. Thus, we preserve all the information: we know the sum of the two values, but we can also find out how it was calculated.

::code-group
```python [Addition function]
def addition(int_a, int_b):
    if type(int_a) == type(int_b) == type(1):
        return (int_a, int_b, int_a + int_b)
    else:
        return "TYPE ERROR"

print(addition(12, 8))
```

```bash [result]
(12, 8, 20)

```
::

::warning
A tuple cannot be modified once created.
::

```py 
my_tuple = (1, 2, 3)
# Trying to modify an element raises an error
my_tuple[1] = 4  # This generates an error
```

